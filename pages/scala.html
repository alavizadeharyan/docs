<!DOCTYPE html>
<html lang="en">
<head>
    <title>Scala</title>
    <meta charset="utf-8">
    <!--
    <script type="text/javascript" src="../live.js"></script>
    -->
    <script id="MathJax-script" async src="../mathjax/tex-chtml.js"></script>
    <link rel="stylesheet" href="../fontawesome-free/css/all.css">
    <script src="../loadPrismTheme.js"></script>
    <link rel="stylesheet" href="../myStyle.css">
    <link rel="stylesheet" href="../search.css">
</head>

<body class="line-numbers" style="font-family: Mulish">
    <script>
        document.body.classList.add(themeMode);
    </script>
    <div class="sticky-container">
        <div class="toc"></div>
        <div class="toolBar">
            <div class="inner-wrapper">
                <div class="homeButton" style="left: 0; top: 10px;"></div>
                <div class="themeButton" style="left: 50px; top: 10px;"></div>
                <div class="searchContainer" style="right: 0; top: 10px;"></div>
            </div>
        </div>
    </div>

    <div class="content" style="padding-bottom: 50px; padding-top: 50px;">

        <h1>Scala</h1>
        <h2>Code Body</h2>
            <pre><code class="language-scala">
                object Tutorial {
                    def main(args: Array[String]): Unit = {
                      // the code body goes here
                    }
                }
            </code></pre>

            <ul>
                <li>Here, the method <code>main</code> takes the command line arguments, an array of strings, as the parameters.</li>
                <li><code>Unit</code> is equivalent to <code>void</code>.</li>
            </ul>

        <h2>Displaying to the standard output</h2>
        <pre><code class="language-scala">
            var myName = "Arian"
            val myAge = 30
            val myWeight = 70.5
            print(s"My name is $myName and ")
            printf("I am %d years old. ", myAge)
            println(f"My weight is $myWeight%.2f kg.")
        </code></pre>

        <ul>
            <li>The <code>s</code> interpolator allows you to plug in variables or expressions, while the <code>f</code> interpolator allows you to use formatting commands.</li>
            <li>The difference between <code>print</code> and <code>println</code> is that the latter adds a newline to the end of the string, while, the former one does not.</li>
        </ul>

        <h2>Reading from the standard input</h2>
        You can use the methods:
        <ul>
            <li><code>scala.io.StdIn.readLine()</code> for reading strings,</li>
            <li><code>scala.io.StdIn.readInt()</code> for reading integers,</li> 
            <li><code>scala.io.StdIn.readFloat()</code> for reading floats,</li>
            <li><code>scala.io.StdIn.readDouble()</code> for reading floats,</li>
            <li><code>scala.io.StdIn.readByte()</code> for reading bytes.</li>
        </ul>
        
        <pre><code class="language-scala">
        var myString = ""
        myString = scala.io.StdIn.readLine()
        </code></pre>

        <h2>Strings</h2>
        <ul>
            <li>The strings should be specified inside double quotations, i.e. <code>"string"</code>.</li>
            <li><code>str.length</code> returns the length of the string <code>str</code>.</li>
            <li><code>str(i)</code> returns the i<sup>th</sup> character of <code>str</code>.</li>
            <li><code>str1.concat(str2)</code> concatenates the two strings <code>str1</code> and <code>str2</code>.</li>
            <li><code>str1.equals(str2)</code> returns <code>true</code> if the two strings <code>str1</code> and <code>str2</code> equals and returns <code>false</code> otherwise.</li>
            <li><code>str1.indexOf(str2)</code> returns back the index of the first appearance of <code>str2</code> in <code>str1</code>. If <code>str2</code> does not appear in <code>str1</code>, the method returns -1.</li>
            <li><code>str.toArray</code> converts the string <code>str</code> to an array.</li>
        </ul>

        <h2>if/else</h2>
        <pre><code class="language-scala">
            if (x < 0) {
              println("negative")
            } else if (x == 0) {
              println("zero")
            } else {
              println("positive")
            }
        </code></pre>

        <h2>For loop</h2>
        <pre><code class="language-scala">
            for (i <- 1 to 3 if i%2==0)
              println(i)
        </code></pre>
                
        <ul>
            <li>One should use the brackets <code>{}</code> if the loop body is more than one line.</li>
            <li>The <code>if</code> statement in the loop condition is called <code>guard</code>.</li>
        </ul>
            
        In case you have nested <code>for</code> loops, even with guards, you can write the code as follows:
            
        <pre><code class="language-scala">
            for {
              i <- 1 to 3
              j <- 'a' to 'c'
              if i == 2
              if j == 'b'
            } {
              println(s"i = $i, j = $j")
            }
        </code></pre>
            
        which is equivalent to:
            
        <pre><code class="language-scala">
            for (i <- 1 to 3 if i == 2)
              for (j <- 'a' to 'c' if j == 'b')
                println(s"i = $i, j = $j")
        </code></pre>
            
            
        <ul>
            <li>Note that <code>i < 1 to 3</code> is inclusive, i.e. the end of the interval is included. In case of an exclusive loop condition, one can use the keyword <code>until</code> instead of <code>to</code>.</li>
        </ul>
        

        <h2>List</h2>

        <pre><code class="language-scala">
            val foo = List("This", "is", "a", "sample", "text.")
            val evenNums = for (i <- 1 to 20 if i%2==0) yield i
        </code></pre>
        
        
        <ul>
            <li>There are two different data types <code>var</code> and <code>val</code> in scala. The former stands for <i>variable</i> which can change along the program, but the latter stands for <i>value</i> which is fixed, and it can not change.</li>
        </ul>
        
        
        <h2>Methods (functions)</h2>
        
        <pre><code class="language-scala">
            def methodName(param1: Type, param2: Type): Type =
              // the method body goes here
            end methodName
        </code></pre>
        
        
        <ul>
            <li>Declaring the method return type is optional</li>
            <li>Providing the <code>end methodName</code> portion after the method body is also optional, and is only recommended for long methods</li>
            <li>If any of the method parameters has a default value, it can be specified as <code>param: Type = default</code>.</li>
        </ul>
        
        <p style="margin: 50px 0 0 0 ">
            <b>Example 1:</b> A method which determines if an input integer is prime or not
        </p>

        <pre><code class="language-scala">
            object MethodTutorial {
            
              def is_prime(n: Int): Boolean = {
                for (i <- 2 to n-1){
                  if (n%i == 0)
                    return false
                }
                return true
              }
          
              def main(args: Array[String]): Unit = {
                println(is_prime(n=args(0).toInt))
              }
            }
        </code></pre>
       
        <p style="margin: 50px 0 0 0 ">
            <b>Example 2:</b> A method which takes a <i>bunch</i> of integers and returns their summation
        </p>
        
        <pre><code class="language-scala">
            def getSum(args: Int*): Int = {
              var sum: Int = 0
              for (num <- args){
                sum += num
              }
              sum
            }
        </code></pre>
        
        <p style="margin: 50px 0 0 0 ">
            <b>Example 3:</b> A method which calculates the factorial of an input integer in a recursive way
        </p>
        
        <pre><code class="language-scala">
            def factorial(n: Int): BigInt = {
              if (n==1){
                1
              }
              else
                n * factorial(n-1)
            }
        </code></pre>

        <h2>Array</h2>

        <pre><code class="language-scala">
            // Initializing an array without assigning values
            val myArray = new Array[Type](size)
            
            // Assigning value to myArray at the position idx
            myArray(idx) = value
            
            // Initializing an array with values
            val myArray = Array(value1, value2)
        </code></pre>
        
        
        <ul>
            <li><code>value1</code> and <code>value2</code> in the above code can be of different types.</li>
        </ul>
        
        
        <h2>ArrayBuffer</h2>
        
        <code>Array</code> is not resizable. In order to be able to resize
        an array by appending new elements to the beginning,
        ending or middle of the array, one can use
        <code>ArrayBuffer</code>:
        
        <pre><code class="language-scala">
            import scala.collection.mutable.ArrayBuffer
            
            // Initializing an array without assigning values and size
            val myArray = ArrayBuffer[Type]()
            
            // Insert value1 in the position 0 of myArray
            myArray.insert(0, value1)
            
            // Appending value2 to myArray
            myArray += value2
            
            // Appending an array to myArray
            myArray ++= Array(value3, value4)
            
            // Changing the value of myArray at the position idx
            myArray(idx) = value5
            
            // Creating a new room at the position idx by pushing the
            // rest of the elements to the right and assigning value6
            // to it
            myArray.insert(idx, value6)
            
            // Removing k elements starting the position idx
            myArray.remove(idx, k)
            
            // Display each element of myArray in a new line
            myArray.foreach(println)
        </code></pre>
        
        
        <ul>
            <li>Use either of <code>myArray.length</code> or <code>myArray.size</code> to get the length of <code>myArray</code>.</li>
        </ul>
        
        <h2>Some mathematical operations over arrays of numbers</h2>
        
        For an array of numbers, no matter if it is defined by <code>Array</code> or
        <code>ArrayBuffer</code>, one can do some mathematical
        operations:
        
        <pre><code class="language-scala">
            val myArray = Array(1.2, .75, .25, 2.3, -1)
            
            val max = myArray.max
            val min = myArray.min
            val sum = myArray.sum
            val ascArray = myArray.sortWith(_<_)
            val desArray = myArray.sortWith(_>_)
        </code></pre>
        
        <h2>Multi-dimensional array</h2>

        <pre><code class="language-scala">
            val two_dim_array = Array.ofDim[Int](10,10)
            for {
              i <- 0 to 9
              j <- 0 to 9
            } {
              two_dim_array(i)(j) = i * j
            }
        </code></pre>
        
        <h2>Maps</h2>
        
        <pre><code class="language-scala">
            // Immutable maps (key-value pairs can not change)
            val myMap = Map(key1 -> value1, key2 -> value2)
            
            // Mutable maps (key-value pairs can be changed or later assigned)
            val myMutableMap = collection.mutable.Map(key1 -> value1)
            myMutableMap(key2) = value2
            
            // For loop on maps
            for ((k,v) <- myMap){
              println(s"$k: $v")
            }

            // Check if a map contains a key
            myMap.contains(key)    // Returns boolean
        </code></pre>

        <h2>Tuples</h2>

        <pre><code class="language-scala">
            val myTuple = (value1, value2, value3)
            
            // Accessing the second element of myTuple (value2)
            println(myTuple._2)
            
            // Iteration over the tuple elements
            for (x <- myTuple.productIterator){
              println(x)
            }
        </code></pre>
        

        <h2>Classes</h2>
        
        Like many other languages scala allows to create classes. Classes may contain fields (values and
        variables) and methods.
        
        <pre><code class="language-scala">
            object ClassTutorial {
            
              class Employee(var name: String = "UNK" , var position: String = "UNK") {
                // Class fields can also be defined inside the class body
                private val id = Employee.newIdNum
            
                // Getters
                def getName: String = name
                def getPosition: String = position
                def getId: Int = id
            
                // Setters
                def setName(foo: String): Unit = {
                  //Check if the String contains numbers and if so don't allow
                  if(!(foo.matches(".*\d+.*")))
                    this.name = foo
                  else
                    this.name = "UNK"
                }
            
                def setPosition(position: String): Unit = {
                  this.position = position
                }
            
                override def toString: String = {
                  return "%s with the id %d works as %s".format(
                    this.name, this.id, this.position)
                }
              } // End of class
          
          
              // The companion object for the class Employee
              object Employee {
                var idNumber = 0
                private def newIdNum: Int = {
                  idNumber += 1
                  return idNumber 
                }
              }
          
          
              def main(args: Array[String]): Unit = {
                val unk = new Employee
                val julien = new Employee("Mike", "Program Manager")
                julien.setName("Mike Anderson")
                println(julien.name)
                println(julien.position)
                println(julien.getId)
                println(julien.toString)
              }
          
            }
        </code></pre>
        
        
        <ul>
            <li>The companion object for a class is where you'd define static class variables and functions in Java.</li>
        </ul>

        
        <h2>Inheritance</h2>
        
        A class that inherits from another gains all its fields and methods. In the following example, the class
        <code>Intern</code> inherits from the class <code>Employee</code>, provided in the
        <a href="#classes">clsasses</a> section:
        
        <pre><code class="language-scala">
            class Intern(name: String = "UNK",
                         position: String = "UNK",
                         var school: String = "UNK") extends Employee(name, position){
            
              def getSchool: String = school
                        
              def setSchool(school: String): Unit = {
                this.school = school
              }

              override def toString: String = {
                return "%s with the id %d is a %s intern from %s".format(
                  this.name, this.getId, this.position, this.school)
              }
          
            }


            def main(args: Array[String]): Unit = {
              val julien = new Employee("Mike Anderson", "Program Manager")
              val boris = new Intern("Boris Jones", "Data Scientist", "Paris-Saclay")
              println(julien.toString)
              println(boris.toString)
            }
        </code></pre>
        
        
        <ul>
            <li>A class declared as final can not be extended.</li>
            <li>In the constructor of a child class, the inherited fields should not be declared as <code>val</code> nor <code>var</code>.</li>
            <li>The child classes do not have access to the private members of the parent class.</li>
        </ul>

        
        <h2>Abstract classes</h2>
        
        <pre><code class="language-scala">
            abstract class Student(val name: String){
              // An abstract field has no initial value
              var age: Int
              // An abstract method has no body
              def showInfo: String
            }

            class FirstGrade(name: String) extends Student(name){
              var age = 7
              // Do not override when defining abstract fields
              def showInfo = "%s is %d years old".format(this.name, this.age)
            }
        </code></pre>
        

        <h2>Traits</h2>
        
        In Scala, a <code>trait</code> is similar to an <code>interface</code> in
        Java. Unlike Java interfaces, traits can provide <i>concrete</i> methods and fields,
        i.e., methods and fields which are directly defined in the trait body. The
        following example shows two traits <code>Real</code> and <code>Imaginary</code>
        which are later used to create the class <code>Complex</code>:
        
        <pre><code class="language-scala">
            trait Real{
              def Re: Double
              def ReToString: String = Re.toString
            }

            trait Imaginary{
              def Im: Double
              def ImToString: String = {
                if(Im==0){
                  return ""
                } else if(Im > 0){
                  return "+"+Im.toString+"i"
                } else{
                  return Im.toString+"i"
                }
              }
            }

            class Complex(var real: Double = 0.0, var imaginary: Double = 0.0)
            extends Real with Imaginary{
              def Re = real
              def Im = imaginary
              override def toString: String = {
                if(Re==0 && Im!=0)
                  return ImToString
                else
                  return ReToString + ImToString
              }
            }
        </code></pre>
        
        <ul>
            <li>
                While declaring a class, for extending more than two traits use the syntax:
                <pre><code class="language-scala">
                    class myClass extends Trait1 with Trait2 with Trait3 with ...
                </code></pre>
            </li>
        </ul>
        

        <h2>Higher order functions</h2>
        
        One can apply a method to all items of a list with <code>map</code>. The method can be
        either predefined or anonymous:
        
        <pre><code class="language-scala">
            val myList = List(100.0, 1000.0, 10000.0)
            
            // log10 is already defined and exists in scala.math
            println(myList.map(scala.math.log10))
            
            // An anonymous method that receives an Int x and divides it by 50
            println(myList.map((x: Double) => x/50))
        </code></pre>
        
        
        <ul>
            <li>The output of <code>myList.map(method)</code> is a list as well.</li>
        </ul>
        
        One can filter a list using <code>filter</code>. This utility allows you to
        retain only those items of the list that meet a certain condition.
        
        <pre><code class="language-scala">
            val myList = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
            println(myList.filter(_ % 2 == 0))
        </code></pre>
        
        
        <ul>
            <li>It is important to note that <code>_ % 2 == 0</code> is a method that receives a number and returns <code>true</code> if the number is even, otherwise it returns <code>false</code>.</li>
            <li>More generally, one can use the syntax <code>myList.filter(method)</code> in which <code>method</code> is a function returning a <code>Boolean</code> necessarily. In this case, only those items of <code>myList</code> are retained for which <code>method</code> returns <code>true</code>.</li>
        </ul>
        
        Methods can be passed to a method as input in scala:
        
        <pre><code class="language-scala">
            def myMethod(func: (Double)=>Double, num: Double): Double = {
              return func(num)
            }
            println(myMethod(scala.math.exp, 2))
        </code></pre>
        
        <ul>
            <li>Note that here <code>(Double)=>Double</code> declares a datatype, and that is any function which receives a <code>Double</code> and returns a <code>Double</code>.</li>
        </ul>
        

        <h2>File I/O</h2>
        
        Use <code>java.io.FileWriter</code> to write into a file:
        
        <pre><code class="language-scala">
            import java.io.FileWriter
            
            val writer = new FileWriter("test.txt")
            // For appending a text uncomment the following line
            //val writer = new FileWriter("test.txt", true)
            writer.write("This is a sample text.\n")
            writer.write("And this is another one.")
            writer.close()
        </code></pre>
        
        Use <code>scala.io.Source</code> to read from a file:
        
        <pre><code class="language-scala">
            import scala.io.Source
            
            val reader = Source.fromFile("test.txt", "UTF-8")
            val lines = reader.getLines()
            lines.foreach(println)
            reader.close()
        </code></pre>
        
        <h2>Exception handling</h2>
        
        <pre><code class="language-scala">
            def divideNums(num1: Int, num2: Int) =
              try{
                // If no error rises, the code here would be implemented
                num1 / num2
              } catch {
                // If error rises, the code here would be implemented
                case ex: java.lang.ArithmeticException => "ERROR"
              } finally {
                // Clean up after exception here
              }
        </code></pre>

    </div>
    <script src="../search.js"></script>
    <script src="../main.js"></script>
    <script src="../prism/prism.js"></script>
</body>
</html>

